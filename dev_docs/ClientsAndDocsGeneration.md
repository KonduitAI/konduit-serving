# Generating Clients And Reference Documentation

## Context 

RESTful clients are generated by annotating fields/classes with `io.swagger.v3.oas.annotations.media.Schema` annotation using `swagger-annotations` module as a dependency. Due to the distribution of inherited classes (for PipelineStep) among multiple modules inside `konduit-serving` we are unable to define the class relationships using `io.swagger.v3.oas.annotations.media.DiscriminatorMapping` as we don't have access to the class references in the `konduit-serving-pipeline` module. Due to this limitation, there's a separate `konduit-serving-clients` module that's responsible to have all the required dependencies for all the required classes and resources which are then used to create annotations at runtime using `org.javassist:javassist` library. Although we can't use `@Schema` for discriminator mappings directly on top of the base classes, we can still use it for writing descriptions and other documentation properties like access modes, default values or visibility modifiers. For example: 

```java
@Schema(description = "A pipeline step that simply logs the input Data keys (and optionally values) and returns " +
        "the input data unchanged.")
public class LoggingPipelineStep implements PipelineStep {

    @Schema(description = "An enum specifying what part of a data instance should be logged. <br><br>" +
            "KEYS -> only output data keys, <br>" +
            "KEYS_AND_VALUES -> output both data keys and values.")
    public enum Log { KEYS, KEYS_AND_VALUES }

    @Builder.Default
    @Schema(description = "Log level. This is similar to how standard logging frameworks define logging categories.",
            defaultValue = "INFO")
    private Level logLevel = Level.INFO;

    @Builder.Default
    @Schema(description = "An enum specifying what part of a data instance should be logged.", defaultValue = "KEYS")
    private Log log = Log.KEYS;

    @Builder.Default
    @Schema(description = "A regular expression that allows filtering of keys - i.e., only those that match the regex will be logged.")
    public String keyFilterRegex = null;
    
}
```

Notice the use of `<br>` as an indication of a line break in the documentation.

## Main entry point

The main entry point for generating clients is `ai.konduit.serving.clients.generators.GenerateRestClients`. This class can be run directly, which will then produce (as of 19/06/2020) `java` and `python` clients in the `<root>/clients` folder. These can be directly compiled afterwards with `mvn clean install` or `python setup.py install` in their respective folders. 

## Limitations of using `org.javassist:javassist`

Although `javassist` is pretty useful in creating annotations at runtime, it's still very brittle in the sense that you'll have to be very careful of the order in which the classes are instantiated at runtime after introspection. If you have already instantiated a class using `Class#forName` you won't be able to call `CtClass#toClass` because of `java.lang.LinkageError: attempted duplicate class definition` exception. 

### Workaround

The way to counter this behavior is to have class relationships defined in a separate file which is then simply read by the `GenerateRestClients` class on runtime. One example of such file is `<root>/konduit-serving-metadata/konduit-serving-meta/target/classes/META-INF/konduit-serving/JsonNameMapping` (available after compilation) which defines all the stuff we need to define class relationships for `discriminatorMappings` and `discriminatorProperty` inside `Schema`. 

## Documenting New Pipeline Steps

Documentating a new pipeline step is pretty straightforward. Just make sure that it implements from `ai.konduit.serving.pipeline.api.step.PipelineStep` and then add `@Schema` annotations to the main class and its respective fields. For example:

```java
@Schema(description = "Main class description")
public class NewPipelineClass implements PipelineStep {
    
    @Builder.Default
    @Schema(description = "Description of first field.",
            defaultValue = "defaultValue1")
    private String firstField = "defaultValue1";

    @Builder.Default
    @Schema(description = "Description of second field.",
            defaultValue = "defaultValue2")
    private String secondField = "defaultValue2";
    
}
```

