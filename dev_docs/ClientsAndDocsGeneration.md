# Konduit Serving Clients

Konduit Serving clients are small/light-weight libraries used to perform inference on servers, hosting models, without needing a full set of Konduit Serving dependencies available in the user's project.

Clients are available in Python and Java, with many more being planned for the future. These clients allow for both running inferences through REST API calls and creation/configuration of new pipelines.

# Generating Clients And Reference Documentation

### Annotating Pipeline Steps?

We use an annotation-based approach via [OpenAPI and Swagger](https://swagger.io/specification/) to generate the clients, based on the Java source code.

All pipeline steps in Konduit Serving and all configuration classes used in pipeline steps should be annotated; once they are annotated, any new PipelineStep will automatically be made available (with docs) in each client language we support.

#### Example of Documenting a New Pipeline Steps

Documentating a new pipeline step is pretty straightforward. Just make sure that it is implemented from `ai.konduit.serving.pipeline.api.step.PipelineStep` and then add `@Schema` annotations to the main class and its respective fields. For example:

```java
@Schema(description = "Main class description")
public class NewPipelineClass implements PipelineStep {
    
    @Schema(description = "Description of first field.",
            defaultValue = "defaultValue1")
    private String firstField = "defaultValue1";
    
    @Schema(description = "Description of second field.",
            defaultValue = "defaultValue2")
    private String secondField = "defaultValue2";
    
}
```

## Specfying REST API methods

For now, the REST APIs are manually specified in the main Open API [configuration](https://github.com/KonduitAI/konduit-serving/blob/5846f31ce7f24393edb99cb99c7e65349de2f79b/konduit-serving-clients/src/main/java/ai/konduit/serving/clients/generators/GenerateRestClients.java#L315-L350). This process has to be manually done at this point. Later on we'll implement annotations based approach to specifying and generating REST API methods as well.  

# Internal Workflow 

RESTful clients are generated by annotating fields/classes with `io.swagger.v3.oas.annotations.media.Schema` annotation using `swagger-annotations` module as a dependency. Due to the distribution of inherited classes (for PipelineStep) among multiple modules inside `konduit-serving` we are unable to define the class relationships using `io.swagger.v3.oas.annotations.media.DiscriminatorMapping` as we don't have access to the class references in the `konduit-serving-pipeline` module. Due to this limitation, there's a separate `konduit-serving-clients` module that's responsible to have all the required dependencies for all the required classes and resources which are then used to create annotations at runtime using `org.javassist:javassist` library. Although we can't use `@Schema` for discriminator mappings directly on top of the base classes, we can still use it for writing descriptions and other documentation properties like access modes, default values or visibility modifiers. For example: 

```java
@Schema(description = "A pipeline step that simply logs the input Data keys (and optionally values) and returns " +
        "the input data unchanged.")
public class LoggingPipelineStep implements PipelineStep {

    @Schema(description = "An enum specifying what part of a data instance should be logged. <br><br>" +
            "KEYS -> only output data keys, <br>" +
            "KEYS_AND_VALUES -> output both data keys and values.")
    public enum Log { KEYS, KEYS_AND_VALUES }

    @Schema(description = "Log level. This is similar to how standard logging frameworks define logging categories.",
            defaultValue = "INFO")
    private Level logLevel = Level.INFO;

    @Schema(description = "An enum specifying what part of a data instance should be logged.", defaultValue = "KEYS")
    private Log log = Log.KEYS;

    @Schema(description = "A regular expression that allows filtering of keys - i.e., only those that match the regex will be logged.")
    public String keyFilterRegex = null;
    
}
```

Notice the use of `<br>` as an indication of a line break in the documentation.

## Main entry point

The main entry point for generating clients is `ai.konduit.serving.clients.generators.GenerateRestClients`. This class can be run directly, which will then produce (as of 19/06/2020) `java` and `python` clients in the `<root>/clients` folder. These can be directly compiled afterwards with `mvn clean install` or `python setup.py install` in their respective folders. 

## Limitations of using `org.javassist:javassist`

Although `javassist` is pretty useful in creating annotations at runtime, it's still very brittle in the sense that you'll have to be very careful of the order in which the classes are instantiated at runtime, after introspection. If you have already instantiated a class using `Class#forName` you won't be able to call `CtClass#toClass` because of `java.lang.LinkageError: attempted duplicate class definition` exception. 

### Workaround

The way to counter this behavior is to have class relationships defined in a separate file which is then simply read by the `GenerateRestClients` class on runtime. One example of such file is `<root>/konduit-serving-metadata/konduit-serving-meta/target/classes/META-INF/konduit-serving/JsonNameMapping` (available after compilation) which defines all the stuff we need to define class relationships for `discriminatorMappings` and `discriminatorProperty` inside `Schema`. 

# Future Work

In the near future we'll add some polish on top of the generated clients by creating simple wrappers in each language to improve the UX, significantly. Also, we'll have proper distribution mechanisms for the generated clients (like maven or pip etc).
